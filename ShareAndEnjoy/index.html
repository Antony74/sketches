<!doctype html>
<html lang="en">
<head>
    <title>Share and Enjoy</title>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_SVG.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/processing.js/1.4.8/processing.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
</head>
<body>
    <p>$$h$$</p>

    <canvas id="myCanvas"></canvas>

    <script>

        MathJax.Hub.Queue(function()
        {
            var canvas = document.getElementById('myCanvas');

            new Processing(canvas, function(processing)
            {
                processing.setup = function()
                {
                    var html = '<svg>' + $('svg').html() + '</svg>';
                    var xml = processing.loadXML(html);
                    var myShape = new processing.PShapeSVG(xml);

                    processing.size(600, 600);
                    processing.background(128, 255, 128);
                    processing.translate(75, 550);
                    processing.scale(0.70, -0.70);
                    processing.rectMode(processing.CENTER);
    
                    prepareShape(myShape);
                }

                function prepareShape(shape)
                {
                    for (var n = 0; n < shape.getChildCount(); ++n)
                    {
                        prepareShape(shape.getChild(n));
                    }

                    if (shape.vertices.length)
                    {
                        var arrRemains = [shape.vertices];
                        var arrConvex = [];

                        while (arrRemains.length)
                        {
                            var concavePolygon = arrRemains.pop();

                            var convexPolygon = getConvexComponentPolygon(concavePolygon);
                            arrConvex.push(convexPolygon);

                            var oRemains = polygonSubtract(concavePolygon, convexPolygon);

                            arrRemains = arrRemains.concat(oRemains['arrRemains']);
                            arrConvex = arrConvex.concat(oRemains['arrSimpleRemains']);
                        }

                        for (var n = 0; n < arrConvex.length; ++n)
                        {
                            drawPolygon(arrConvex[n]);
                        }

                        drawVertices(shape.vertices);
                    }
                }

                function drawVertices(vertices)
                {
                    for (var n = 0; n < vertices.length; ++n)
                    {
                        var x = vertices[n][0];
                        var y = vertices[n][1];

                        drawVertex(x, y);
                    }
                }

                function drawVertex(x, y)
                {
                    processing.pushStyle();
                    processing.noStroke();
                    processing.fill(255, 0, 0, 128);
                    processing.rect(x, y, 15, 15);
                    processing.popStyle();
                }

                function drawPolygon(vertices)
                {
                    processing.beginShape();
                    for (var n = 0; n < vertices.length; ++n)
                    {
                        var vertex = vertices[n];
                        var x = vertex[0];
                        var y = vertex[1];

                        processing.vertex(x,y);
                    }
                    processing.endShape(processing.CLOSE);
                }

                function getConvexComponentPolygon(concaveVertices)
                {
					var convexVertices = [];

					for (var n = 0; n < concaveVertices.length; ++n)
					{
						var vertex = concaveVertices[n];
						convexVertices.push(vertex);

						if (convexVertices.length >= 3)
						{
							var p0 = convexVertices[0];
							var p1 = convexVertices[convexVertices.length - 3];
							var p2 = convexVertices[convexVertices.length - 2];
							var p3 = convexVertices[convexVertices.length - 1];

							var retval1 = ccw(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
							var retval2 = ccw(p2[0], p2[1], p3[0], p3[1], p0[0], p0[1]);

							if (retval1 > 0)
							{
								convexVertices.pop();
							}
							else if (retval2 > 0)
							{
								convexVertices.shift();
							}
						}
					}

                    return convexVertices;
                }

                //
                // ccw - the counter-clockwise function
                //
                // Also see https://en.wikipedia.org/wiki/Graham_scan
                //
                function ccw(x1, y1, x2, y2, x3, y3)
                {
                    return ((x2 - x1)*(y3 - y1)) - ((y2 - y1)*(x3 - x1));
                }

                function polygonSubtract(polyOriginal, polySubtract)
                {
                    var arrRemains = [];
                    var arrSimpleRemains = [];

                    if (polySubtract.length == 0)
                    {
                        return arrRemains; // There's no work here that needs doing
                    }

                    // Clone polySubtract so we don't modify the object we were originally passed
                    polySubtract = JSON.parse(JSON.stringify(polySubtract));

                    // Close it
                    polySubtract.push(polySubtract[0]);

                    var nOrig = 0;
                    var nPass = 0;

                    var arrVertices = [];

                    for (var nSub = 0; nSub < polySubtract.length; ++nSub)
                    {
                        var arrVertices = [];

                        while (!verticesEqual(polyOriginal[nOrig], polySubtract[nSub]))
                        {
                            arrVertices.push(polyOriginal[nOrig]);
                            ++nOrig;

                            if (nOrig >= polyOriginal.length)
                            {
                                nOrig = 0;
                                ++nPass;
                                if (nPass > 1)
                                {
                                    break;
                                }
                            }
                        }

                        if (arrVertices.length > 1 && nSub > 0)
                        {
                            var polyRemains = [polySubtract[nSub]].concat(arrVertices);
                            if (polyRemains.length > 3)
                            {
                                arrRemains.push(polyRemains);
                            }
                            else
                            {
                                // Polygons with only three vertices are automatically convex
                                arrSimpleRemains.push(polyRemains);
                            }
                        }
                    }

                    return {'arrRemains': arrRemains, 'arrSimpleRemains':arrSimpleRemains};
                }

                function verticesEqual(v1, v2)
                {
                    return (v1[0] == v2[0]) && (v1[1] == v2[1]);
                }

            });
        });

    </script>

</body>
</html>

