<!doctype html>
<html lang="en">
<head>
    <title>Share and Enjoy</title>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_SVG.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/processing.js/1.4.8/processing.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
</head>
<body>
    <p>$$h$$</p>

    <canvas id="myCanvas"></canvas>

    <script>

        MathJax.Hub.Queue(function()
        {
            var canvas = document.getElementById('myCanvas');

            var processing = new Processing(canvas, function(processing)
            {
                processing.setup = function()
                {
                    var html = '<svg>' + $('svg').html() + '</svg>';
                    var xml = processing.loadXML(html);
                    var myShape = new processing.PShapeSVG(xml);

                    processing.size(800, 800);
                    processing.background(128, 255, 128);
                    processing.translate(75, 700);
                    processing.scale(0.8, -0.8);
                    processing.rectMode(processing.CENTER);
    
                    prepareShape(myShape);

//                    processing.shape(myShape);
                }

                function prepareShape(shape)
                {
                    for (var n = 0; n < shape.getChildCount(); ++n)
                    {
                        prepareShape(shape.getChild(n));
                    }

                    if (shape.vertices.length)
                    {
                        var arr = convexify(shape.vertices);
                        for (var n = 0; n < arr.length; ++n)
                        {
                            drawPolygon(arr[n]);
                        }
                        drawVertices(shape.vertices);
                    }
                }

                function drawVertices(vertices)
                {
                    for (var n = 0; n < vertices.length; ++n)
                    {
                        var x = vertices[n][0];
                        var y = vertices[n][1];

                        drawVertex(x, y);
                    }
                }

                function drawVertex(x, y)
                {
                    processing.pushStyle();
                    processing.noStroke();
                    processing.fill(255, 0, 0, 128);
                    processing.rect(x, y, 30, 30);
                    processing.popStyle();
                }

                function drawPolygon(vertices)
                {
                    processing.beginShape();
                    for (var n = 0; n < vertices.length; ++n)
                    {
                        var vertex = vertices[n];
                        var x = vertex[0];
                        var y = vertex[1];

                        processing.vertex(x,y);
                    }
                    processing.endShape(processing.CLOSE);
                }

                function convexify(concaveVertices)
                {
                    var convexVertices = [];

                    for (var n = 0; n < concaveVertices.length; ++n)
                    {
                        var vertex = concaveVertices[n];

                        if (convexVertices.length < 2)
                        {
                            convexVertices.push(vertex);
                        }
                        else
                        {
                            var p1 = convexVertices[convexVertices.length - 2];
                            var p2 = convexVertices[convexVertices.length - 1];
                            var p3 = vertex;

                            var retval = ccw(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);

                            if (retval <= 0)
                            {
                                convexVertices.push(vertex);
                            }
                        }
                    }

                    return [convexVertices];
                }

                //
                // ccw - the counter-clockwise function
                //
                // Also see https://en.wikipedia.org/wiki/Graham_scan
                //
                function ccw(x1, y1, x2, y2, x3, y3)
                {
                    return ((x2 - x1)*(y3 - y1)) - ((y2 - y1)*(x3 - x1));
                }

            });
        });

    </script>

</body>
</html>

